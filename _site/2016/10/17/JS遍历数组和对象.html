<h2 id="为了方便例子讲解现有数组和json对象如下">为了方便例子讲解，现有数组和json对象如下</h2>

<blockquote>
  <p><code class="highlighter-rouge">var demoArr = ['Javascript', 'Gulp', 'CSS3', 'Grunt', 'jQuery', 'angular'];
var demoObj = {
    aaa: 'Javascript',
    bbb: 'Gulp',
    ccc: 'CSS3',
    ddd: 'Grunt',
    eee: 'jQuery',
    fff: 'angular'
};</code></p>
</blockquote>

<p><strong>for</strong></p>

<p>可以直接看示例，用得太多了，很简单</p>

<blockquote>
  <p><code class="highlighter-rouge">(function() {
    for(var i=0, len=demoArr.length; i&lt;len; i++) {
        if (i == 2) {
            // return;   // 函数执行被终止
            // break;    // 循环被终止
            continue; // 循环被跳过
        };
        console.log('demo1Arr['+ i +']:' + demo1Arr[i]);
    }
})();</code></p>
</blockquote>

<p>##关于for循环，有一下几点需要注意</p>
<ul>
  <li>for循环中的i在循环结束之后任然存在与作用域中，为了避免影响作用域中的其他变量，使用函数自执行的方式将其隔离起来()();</li>
  <li>避免使用for(var i=0; i 的方式，这样的数组长度每次都被计算，效率低于上面的方式。也可以将变量声明放在for的前面来执行，提高阅读性</li>
</ul>

<blockquote>
  <p><code class="highlighter-rouge">var i = 0, len = demo1Arr.length;
for(; i&lt;len; i++) {};</code></p>
</blockquote>

<h2 id="跳出循环的方式有如下几种">跳出循环的方式有如下几种</h2>
<ul>
  <li>return 函数执行被终止</li>
  <li>break 循环被终止</li>
  <li>continue 循环被跳过</li>
</ul>

<p>完整实例（https://github.com/yangbo5207/front-end-road/blob/master/16.%E5%90%84%E7%A7%8D%E9%81%8D%E5%8E%86%E8%AF%A6%E8%A7%A3/demo1.html）</p>

<p><strong>for in</strong></p>

<p>for(var item in arr|obj){} 可以用于遍历数组和对象</p>
<ul>
  <li>遍历数组时，item表示索引值， arr表示当前索引值对应的元素 arr[item]</li>
  <li>遍历对象时，item表示key值，arr表示key值对应的value值 obj[item]
    <blockquote>
      <p>(function() {
    for(var i in demoArr) {
        if (i == 2) {
            return; // 函数执行被终止
            // break;  // 循环被终止
            // continue;  // 循环被跳过
        };
        console.log(“demoArr[i]:” + demoArr[i]);
    }
    console.log(“————-“);
})();</p>
    </blockquote>
  </li>
</ul>

<p>###关于for in，有以下几点需要注意：</p>
<ul>
  <li>在for循环与for in循环中，i值都会在循环结束之后保留下来。因此使用函数自执行的方式避免。</li>
  <li>使用return，break，continue跳出循环都与for循环一致，不过关于return需要注意，在函数体中，return表示函数执行终止，就算是循环外面的代码，也不再继续往下执行。而break仅仅只是终止循环，后面的代码会继续执行。</li>
</ul>

<blockquote>
  <p><code class="highlighter-rouge">function res() {
    var demoArr = ['Javascript', 'Gulp', 'CSS3', 'Grunt', 'jQuery', 'angular'];
    for(var item in demoArr) {
        if (item == 2) {
            return;
        };
        console.log(item, demoArr[item]);
    }
    console.log('desc', 'function res'); //不会执行
}</code></p>
</blockquote>

<p><strong>forEach</strong></p>

<p>demoArr.forEach(function(arg) {})
参数arg表示数组每一项的元素，实例如下</p>
<blockquote>
  <p><code class="highlighter-rouge">demoArr.forEach(function(val, index) {
    if (e == 'CSS3') {
        return;  // 循环被跳过
        // break;   // 报错
        // continue;// 报错
    };
    console.log(val, index);
})</code></p>
</blockquote>

<p>具体有以下需要注意的地方</p>
<ul>
  <li>回调函数中有2个参数，分别表示值和索引，这一点与jQuery中的$.each相反</li>
  <li>forEach无法遍历对象</li>
  <li>forEach无法在IE中使用，firefox和chrome实现了该方法</li>
  <li>forEach无法使用break，continue跳出循环，使用return时，效果和在for循环中使用continue一致</li>
  <li>最重要的一点，可以添加第二参数，为一个数组，而且回调函数中的this会指向这个数组。而如果没有第二参数，则this会指向window。</li>
</ul>

<blockquote>
  <p><code class="highlighter-rouge">var newArr = [];
demoArr.forEach(function(val, index) {
    this.push(val); // 这里的this指向newArr
}, newArr)</code></p>
</blockquote>

<p>虽然在原生中forEach循环的局限性很多，但是了解他的必要性在于，很多第三方库会扩展他的方法，使其能够应用在很多地方，比如angular的工具方法中，也有forEach方法，其使用与原生的基本没有差别，只是没有了局限性，可以在IE下使用，也可以遍历对象</p>

<blockquote>
  <p><code class="highlighter-rouge">var result = [];
angular.forEach(demoArr, function(val, index) {
    this.push(val);
}, result);</code></p>
</blockquote>

<p><strong>do/while</strong></p>

<p>函数具体的实现方式如下，不过有一点值得注意的是，当使用continue时，如果你将i++放在了后面，那么i++的值将一直不会改变，最后陷入死循环。因此使用do/while一定要小心谨慎一点。</p>

<p>不建议使用do/while的方式来遍历数组</p>

<blockquote>
  <p><code class="highlighter-rouge">// 直接使用while
(function() {
    var i = 0,
        len = demoArr.length;
    while(i &lt; len) {
        if (i == 2) {
            // return; // 函数执行被终止
            // break;  // 循环被终止
            // continue;  // 循环将被跳过，因为后边的代码无法执行，i的值没有改变，因此循环会一直卡在这里，慎用！！
        };
        console.log('demoArr['+ i +']:' + demoArr[i]);
        i ++;
    }
    console.log('------------------------');
})();
// do while
(function() {
    var i = 0,
        len = demo3Arr.length;
    do {
        if (i == 2) {
            break; // 循环被终止
        };
        console.log('demo2Arr['+ i +']:' + demo3Arr[i]);
        i++;
    } while(i&lt;len);
})();</code></p>
</blockquote>

<p><strong>$.each</strong></p>
<blockquote>
  <p><code class="highlighter-rouge">
$.each(demoArr|demoObj, function(e, ele))
可以用来遍历数组和对象，其中e表示索引值或者key值，ele表示value值
$.each(demoArr, function(e, ele) {
    console.log(e, ele);
})</code></p>
</blockquote>

<p>输出为</p>
<blockquote>
  <p>0 “Javascript”
1 “Gulp”
2 “CSS3”
3 “Grunt”
4 “jQuery”
5 “angular”</p>
</blockquote>

<p>这里有很多需要注意的地方</p>

<ul>
  <li>使用return 或者return true为跳过一次循环，继续执行后面的循环</li>
  <li>使用return false为终止循环的执行，但是并不终止函数执行</li>
  <li>无法使用break与continue来跳过循环</li>
  <li>循环中this值输出类似如下</li>
</ul>

<blockquote>
  <p><code class="highlighter-rouge">console.log(this);
//String {0: "C", 1: "S", 2: "S", 3: "3", length: 4, [[PrimitiveValue]]: "CSS3"}
console.log(this == ele);
// true</code></p>
</blockquote>

<p>关于上面的this值，遍历一下</p>
<blockquote>
  <p><code class="highlighter-rouge">
$.each(this, function(e, ele) {
    console.log(e, ele);
})</code>
 
// 0 c
// 1 s
// 2 s
// 4 3</p>
</blockquote>

<p>为什么length 和 [[PrimitiveValue]]没有遍历出来？突然灵光一动，在《javascript高级编程》中找到了答案，大概意思就是javascript的内部属性中，将对象数据属性中的Enumerable设置为了false</p>

<blockquote>
  <p>// 查看length的内部属性
console.log(Object.getOwnPropertyDescriptor(this, ‘length’));
// Object {value: 4, writable: false, enumerable: false, configurable: false}</p>
</blockquote>

<blockquote>
  <p>$.each 中的 $(this) 与this有所不同，不过遍历结果却是一样，你可以在测试代码中打印出来看看</p>
</blockquote>

<p><strong>$(selecter).each</strong></p>

<p>专门用来遍历DOMList</p>
<blockquote>
  <p><code class="highlighter-rouge">
$('.list li').each(function(i, ele) {
    console.log(i, ele);
    // console.log(this == ele); // true
    $(this).html(i);
    if ($(this).attr('data-item') == 'do') {
        $(this).html('data-item: do');
    };
})</code></p>
</blockquote>

<ul>
  <li>i: 序列值 ele: 只当前被遍历的DOM元素</li>
  <li>this 当前被遍历的DOM元素，不能调用jQuery方法</li>
  <li>$(this) == $(ele) 当前被遍历元素的jquery对象，可以调用jquery的方法进行dom操作</li>
</ul>

<p><strong>使用for in 遍历DOMList</strong></p>

<p>因为domList并非数组，而是一个对象，只是因为其key值为0，1，2… 而感觉与数组类似，但是直接遍历的结果如下</p>
<blockquote>
  <p><code class="highlighter-rouge">
var domList = document.getElementsByClassName('its');
for(var item in domList) {
    console.log(item, ':' + domList[item]);
}</code>
// 0: 
// 1: 
//    …
// length: 5
// item: function item() {}
// namedItem: function namedItem() {}</p>
</blockquote>

<p>因此我们在使用for in 遍历domList时，需要将domList转换为数组</p>
<blockquote>
  <p><code class="highlighter-rouge">
var res = [].slice.call(domList);
for(var item in res) {}</code></p>
</blockquote>

<p>类似这样的对象还有函数的属性arguments对象，当然字符串也是可以遍历的，但是因为字符串其他属性的enumerable被设置成了false，因此遍历出来的结果跟数组是一样的，也就不用担心这个问题了.</p>

<p><strong>小补充</strong></p>

<p>如果你发现有些人写函数这样搞，不要惊慌，也不要觉得他高大上鸟不起</p>
<blockquote>
  <p><code class="highlighter-rouge">
+function(ROOT, Struct, undefined) {
    ... 
}(window, function() {
    function Person() {}
})</code></p>
</blockquote>

<p>()(), !function() {}() +function() {}() 三种函数自执行的方式^_^</p>

